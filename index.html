<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pente Grammai â€“ Single Highlight Per Line</title>
  <style>
    /* Basic resets and styling */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      background: #fafafa;
    }
    #gameContainer {
      position: relative;
      width: 500px;
      height: 500px;
      border: 2px solid #555;
      background: #eee;
      margin-bottom: 10px;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #diceArea {
      display: flex;
      width: 500px;
      justify-content: space-between;
      margin-bottom: 10px;
      font-weight: bold;
    }
    #pastMoves {
      width: 180px;
      height: 120px;
      overflow-y: auto;
      background: #fff;
      border: 1px solid #aaa;
      font-size: 14px;
    }
    #pastMoves ul { list-style: none; margin: 0; padding: 0; }
    #pastMoves li { margin: 2px 0; }
  </style>
</head>
<body>
  <h1>Single Highlight Per Line Demo</h1>

  <div id="gameContainer">
    <canvas id="gameCanvas" width="500" height="500"></canvas>
  </div>
  
  <div id="diceArea">
    <div>
      Dice: <span id="diceResult">0</span>
      <button id="diceRollBtn">Roll Dice</button>
    </div>
    <div id="pastMoves">
      <ul id="movesList"></ul>
    </div>
  </div>

  <script>
  'use strict';

  // Basic board constants
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const W = canvas.width;
  const H = canvas.height;

  const LINE_COUNT = 5;        // lines indexed 0..4 (0=top, 4=bottom)
  const COL_COUNT = 1;         // effectively 1 highlight per line
  const CENTER_COL = 6;        // we draw the highlight in column=6 (just for visual x-position)
  const MULTI_LINE = 2;        // line 2 (the center line) can hold multiple pieces

  const PIECE_RADIUS = 15;
  const HIT_TOLERANCE = 10;

  let diceValue = 0;
  let diceRolled = false;
  let currentTurn = 'human';  // or 'ai'

  // We'll store piece objects: { line, color, isAI }
  // line can be 0..4; multiple pieces can be on line=2, but only one piece can be on lines 0..1..3..4
  let pieces = [];

  // For demonstration, 5 blue (human) and 5 red (AI) all start on line=2
  function initPieces() {
    pieces = [];
    // 5 blue (human)
    for (let i = 0; i < 5; i++) {
      pieces.push({ line: 2, color: 'blue', isAI: false });
    }
    // 5 red (AI)
    for (let i = 0; i < 5; i++) {
      pieces.push({ line: 2, color: 'red', isAI: true });
    }
  }

  // DOM references
  const diceResultSpan = document.getElementById("diceResult");
  const diceRollBtn = document.getElementById("diceRollBtn");
  const movesList = document.getElementById("movesList");

  // Setup event for dice roll
  diceRollBtn.addEventListener('click', () => {
    if (currentTurn !== 'human' || diceRolled === true) {
      console.log("Dice roll ignored; not your turn or already rolled.");
      return;
    }
    diceValue = Math.floor(Math.random() * 6) + 1;
    diceRolled = true;
    diceResultSpan.textContent = diceValue;
    addMoveToHistory(`Dice rolled: ${diceValue}`);
  });

  // Canvas click => attempt to move a blue (human) piece
  canvas.addEventListener('mousedown', (e) => {
    if (currentTurn !== 'human' || !diceRolled) {
      console.log("Ignoring click; either not your turn or dice not rolled.");
      return;
    }
    // Get proper mouse coords
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mx = (e.clientX - rect.left) * scaleX;
    const my = (e.clientY - rect.top) * scaleY;

    // Check for a human (blue) piece near the click
    let foundIndex = -1;
    for (let i = 0; i < pieces.length; i++) {
      const piece = pieces[i];
      if (!piece.isAI && piece.color === 'blue') {
        const { x, y } = lineToCoords(piece.line);
        const dx = mx - x;
        const dy = my - y;
        if (Math.sqrt(dx*dx + dy*dy) <= PIECE_RADIUS + HIT_TOLERANCE) {
          foundIndex = i;
          break;
        }
      }
    }
    if (foundIndex === -1) {
      console.log("No blue piece found near click.");
      return;
    }
    // We found a piece
    const p = pieces[foundIndex];
    // Attempt to move p one line up or down (your choice: let's do up if line>0, else down).
    // Or if you want to use dice, do that. For now let's do a single line up or down (like dice=1).
    // We'll interpret diceValue just for logging, not for distance.

    let newLine;
    if (p.line === 2) {
      // If on center line, let's move up if line>2? Actually let's define a strategy:
      // if diceValue is odd => move up, if even => move down (just for demonstration).
      // Adjust as you see fit.
      if (diceValue % 2 === 1 && p.line > 0) {
        newLine = p.line - 1;
      } else if (diceValue % 2 === 0 && p.line < 4) {
        newLine = p.line + 1;
      } else {
        addMoveToHistory("No valid move from center line (maybe dice suggests out-of-bounds?).");
        return;
      }
    } else if (p.line < 2) {
      // If piece is above center, let's move it further up if possible
      // i.e. p.line-1 if >=0
      if (p.line > 0) newLine = p.line - 1;
      else {
        addMoveToHistory("Piece is at top edge. No move possible.");
        return;
      }
    } else {
      // If piece is below center, move it further down if possible
      if (p.line < 4) newLine = p.line + 1;
      else {
        addMoveToHistory("Piece is at bottom edge. No move possible.");
        return;
      }
    }

    // If newLine is a single-line integer
    if (newLine === undefined) {
      return;
    }

    // Check occupancy rules: lines 0,1,3,4 can hold at most 1 piece, line 2 can hold multiple
    if (newLine !== 2) {
      // ensure no piece is on newLine
      if (pieces.some(pp => pp !== p && pp.line === newLine)) {
        addMoveToHistory(`Line ${newLine} is occupied. Move illegal.`);
        return;
      }
    }
    // Move piece
    const oldLine = p.line;
    p.line = newLine;
    addMoveToHistory(`Human moved piece from line ${oldLine} to ${newLine} (dice=${diceValue})`);

    diceRolled = false;
    diceValue = 0;
    diceResultSpan.textContent = "0";
    currentTurn = 'ai';
    redrawBoard();
    setTimeout(aiTurn, 1000);
  });

  // AI turn => each red piece tries to move up or down similarly
  function aiTurn() {
    addMoveToHistory("AI Turn: rolling dice...");
    diceValue = Math.floor(Math.random() * 6) + 1;
    diceResultSpan.textContent = diceValue;
    console.log("AI rolled dice:", diceValue);

    const aiPieces = pieces.filter(p => p.isAI);
    // We attempt to move one AI piece
    let moved = false;
    for (let i = 0; i < aiPieces.length; i++) {
      const p = aiPieces[i];
      let newLine;
      // We'll do a similar approach to the human:
      // if line=2 => move up or down based on diceValue parity
      // if line<2 => move further up, if line>2 => move further down
      if (p.line === 2) {
        if (diceValue % 2 === 1 && p.line > 0) {
          newLine = p.line - 1;
        } else if (diceValue % 2 === 0 && p.line < 4) {
          newLine = p.line + 1;
        } else {
          continue; // skip if out-of-bounds
        }
      } else if (p.line < 2) {
        if (p.line > 0) newLine = p.line - 1;
        else continue;
      } else {
        if (p.line < 4) newLine = p.line + 1;
        else continue;
      }

      // Check occupancy if newLine != 2
      if (newLine !== 2) {
        if (pieces.some(pp => pp !== p && pp.line === newLine)) {
          console.log(`AI piece on line ${p.line} cannot move to line ${newLine} => occupied.`);
          continue;
        }
      }
      const oldLine = p.line;
      p.line = newLine;
      addMoveToHistory(`AI moved piece from line ${oldLine} to ${newLine} (dice=${diceValue})`);
      moved = true;
      break;
    }

    diceValue = 0;
    diceResultSpan.textContent = "0";
    diceRolled = false;
    currentTurn = 'human';
    redrawBoard();
  }

  // Basic draw function => highlight positions are always col=6
  function lineToCoords(line) {
    // We'll put the highlight at col=6 (just visually in the center).
    const rowSpacing = H / (LINE_COUNT + 1);
    const x = (6 + 1) * (W / (TOTAL_COLUMNS + 1)); // col=6 => (6+1)*...
    const y = (line + 1) * rowSpacing;
    return { x, y };
  }

  // Actually draw the pieces
  function redrawBoard() {
    ctx.clearRect(0, 0, W, H);
    // Draw lines
    const rowSpacing = H / (LINE_COUNT + 1);
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2;
    for (let i = 1; i <= LINE_COUNT; i++) {
      let y = i * rowSpacing;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    // Draw pieces
    pieces.forEach((p, idx) => {
      const { x, y } = lineToCoords(p.line);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(x, y, PIECE_RADIUS, 0, Math.PI*2);
      ctx.fill();
    });
  }

  // Move history
  function addMoveToHistory(msg) {
    console.log(msg);
    const li = document.createElement('li');
    li.textContent = msg;
    movesList.appendChild(li);
    movesList.scrollTop = movesList.scrollHeight;
  }

  // On load => init
  initPieces();
  redrawBoard();

  // Demo: if you want to re-init
  // (In a real game, you'd have "New Game" button etc.)
  </script>
</body>
</html>
