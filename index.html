<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented – Pente Grammai</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
      text-align: center;
      line-height: 1.2;
    }
    #gameContainer {
      position: relative;
      width: 500px;
      max-width: 100%;
      margin-bottom: 10px;
    }
    canvas {
      display: block;
      background: #eee;
      width: 100%;
      height: auto;
      border: 2px solid #333;
      touch-action: none;
    }
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255,255,255,0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
      z-index: 10;
    }
    button {
      font-size: 18px;
      padding: 10px 20px;
      margin: 5px;
      cursor: pointer;
    }
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
    #dice {
      margin-top: 20px;
      font-size: 24px;
      font-weight: bold;
    }
  </style>
</head>
<body>

  <h1>Another Product Invented<br>Pente Grammai</h1>

  <div id="gameContainer">
    <canvas id="gameCanvas" width="500" height="500"></canvas>

    <!-- Menu Screen -->
    <div id="menuScreen" class="overlayScreen" style="display:flex;">
      <button id="newGameBtn">New Game</button>
      <button id="instructionsBtn">Instructions</button>
    </div>

    <!-- Difficulty Screen -->
    <div id="difficultyScreen" class="overlayScreen">
      <p>Select Difficulty:</p>
      <button id="easyBtn">Easy</button>
      <button id="mediumBtn">Medium</button>
      <button id="hardBtn">Hard</button>
    </div>

    <!-- Instructions Screen -->
    <div id="instructionsScreen" class="overlayScreen">
      <h2>How to Play Pente Grammai</h2>
      <p>1. All pieces start on the middle line, with you on one side and the AI on the other.</p>
      <p>2. Roll the die to move your pieces anti-clockwise.</p>
      <p>3. Move your pieces to the opposite third line to win.</p>
      <p>4. You cannot land on a space occupied by another piece.</p>
      <p>5. If your dice roll would land you on a blocked space, you must choose another piece to move (if possible).</p>
      <p>6. Pieces cannot enter home if any of your pieces are still in the starting third line.</p>
      <p><strong>Press [M] to return to the Main Menu.</strong></p>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="overlayScreen">
      <h2 id="resultText"></h2>
      <button id="gameOverNewGame">New Game</button>
      <p><strong>Press [M] to return to the Main Menu.</strong></p>
    </div>
  </div>

  <!-- Custom Dice (for development) -->
    <img id="logo" src="logo.png" alt="Logo">

  <script>
    // Game Logic
    let canvas = document.getElementById('gameCanvas'),
        ctx = canvas.getContext('2d'),
        playerPieces = [], // Player's pieces
        aiPieces = [], // AI's pieces
        currentPlayer = 'player', // Player starts first
        gameActive = false,
        difficulty = 'easy';

const lineCount = 5;
const spacesPerLine = 7;
let trackPath = [];

// Create a basic anti-clockwise movement path
function createTrackPath() {
  trackPath = [];

  // Bottom line (left to right)
  for (let i = 0; i < spacesPerLine; i++) {
    trackPath.push({ line: 4, pos: i });
  }

  // Right line (bottom to top, skip bottom already used)
  for (let i = 3; i >= 0; i--) {
    trackPath.push({ line: i, pos: spacesPerLine - 1 });
  }

  // Top line (right to left)
  for (let i = spacesPerLine - 2; i >= 0; i--) {
    trackPath.push({ line: 0, pos: i });
  }

  // Left line (top to bottom, skip top already used)
  for (let i = 1; i < 4; i++) {
    trackPath.push({ line: i, pos: 0 });
  }

  // Center line (middle forward, finish zone)
  for (let i = 1; i < spacesPerLine - 1; i++) {
    trackPath.push({ line: 2, pos: i });
  }
}


    // Initialize the board
function initializeBoard() {
  createTrackPath();

  playerPieces = [{ pathIndex: 0 }, { pathIndex: 1 }, { pathIndex: 2 }];
  aiPieces = [{ pathIndex: 0 }, { pathIndex: 1 }, { pathIndex: 2 }];

  currentPlayer = 'player';
  gameActive = true;
  selectedPieceIndex = null;
  drawBoard();

  if (currentPlayer === 'ai') aiMove(); // If AI starts first later
}

function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "#000";
  ctx.lineWidth = 3;

  const spacingY = canvas.height / (lineCount + 1);
  const spacingX = canvas.width / (spacesPerLine + 1);

  // Draw 5 lines
  for (let i = 1; i <= lineCount; i++) {
    ctx.beginPath();
    ctx.moveTo(spacingX, spacingY * i);
    ctx.lineTo(spacingX * spacesPerLine, spacingY * i);
    ctx.stroke();
  }
  

  // Draw player pieces
  playerPieces.forEach(piece => {
    const spot = trackPath[piece.pathIndex];
    const x = spacingX * (spot.pos + 1);
    const y = spacingY * (spot.line + 1);
    ctx.fillStyle = 'blue';
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();
  });
}

  // Show dice result inside canvas
ctx.fillStyle = 'black';
ctx.font = 'bold 24px sans-serif';
ctx.fillText(`Dice: ${document.getElementById('diceResult').textContent}`, 10, 30);
  // Draw AI pieces
aiPieces.forEach(piece => {
  const spot = trackPath[piece.pathIndex];
  const x = spacingX * (spot.pos + 1);
  const y = spacingY * (spot.line + 1);
  ctx.fillStyle = 'red';
  ctx.beginPath();
  ctx.arc(x, y, 20, 0, Math.PI * 2);
  ctx.fill();
});


    // Roll the die (1-6)
    function rollDie() {
      const result = Math.floor(Math.random() * 6) + 1;
      document.getElementById('diceResult').textContent = result; // Display dice result
      return result;
    }

    // Handle player move
    function playerMove() {
      const dieResult = rollDie();
      alert(`You rolled a ${dieResult}. Move your piece!`);
      // Implement movement logic here based on your rules
    }
    setTimeout(() => {
    currentPlayer = 'ai';
    aiMove();
 }, 600);

    // Handle AI move (based on difficulty)
    function aiMove() {
  if (!gameActive) return;

  const dieResult = rollDie();
  console.log(`AI rolled a ${dieResult}`);

  let moved = false;

  if (difficulty === 'easy') {
    // EASY → Move the first available piece
    for (let i = 0; i < aiPieces.length; i++) {
      if (canMove(aiPieces[i], dieResult, aiPieces, playerPieces)) {
        aiPieces[i].pathIndex += dieResult;
        moved = true;
        break;
      }
    }

  } else if (difficulty === 'medium') {
    // MEDIUM → Try to capture player if possible
    for (let i = 0; i < aiPieces.length; i++) {
      let newIndex = aiPieces[i].pathIndex + dieResult;
      if (newIndex < trackPath.length && playerPieces.some(p => p.pathIndex === newIndex)) {
        aiPieces[i].pathIndex = newIndex;
        moved = true;
        break;
      }
    }
    if (!moved) {
      for (let i = 0; i < aiPieces.length; i++) {
        if (canMove(aiPieces[i], dieResult, aiPieces, playerPieces)) {
          aiPieces[i].pathIndex += dieResult;
          moved = true;
          break;
        }
      }
    }

  } else if (difficulty === 'hard') {
    // HARD → Capture preferred, else avoid stacking behind own pieces
    for (let i = 0; i < aiPieces.length; i++) {
      let newIndex = aiPieces[i].pathIndex + dieResult;
      if (newIndex < trackPath.length && playerPieces.some(p => p.pathIndex === newIndex)) {
        aiPieces[i].pathIndex = newIndex;
        moved = true;
        break;
      }
    }

    if (!moved) {
      for (let i = 0; i < aiPieces.length; i++) {
        let newIndex = aiPieces[i].pathIndex + dieResult;
        if (newIndex < trackPath.length && !aiPieces.some(p => p.pathIndex === newIndex)) {
          aiPieces[i].pathIndex = newIndex;
          moved = true;
          break;
        }
      }
    }

    if (!moved) {
      // If no other move, just move something
      for (let i = 0; i < aiPieces.length; i++) {
        if (canMove(aiPieces[i], dieResult, aiPieces, playerPieces)) {
          aiPieces[i].pathIndex += dieResult;
          break;
        }
      }
    }
  }

  drawBoard();
  currentPlayer = 'player';
}
function canMove(piece, roll, ownPieces, enemyPieces) {
  const targetIndex = piece.pathIndex + roll;
  if (targetIndex >= trackPath.length) return false;
  if (ownPieces.some(p => p.pathIndex === targetIndex)) return false;
  return true;
}
    
    // Event Listeners
    document.getElementById('newGameBtn').onclick = () => showScreen('difficultyScreen');
    document.getElementById('instructionsBtn').onclick = () => showScreen('instructionsScreen');
    document.getElementById('easyBtn').onclick = () => { difficulty = 'easy'; initializeBoard(); showScreen(''); };
    document.getElementById('mediumBtn').onclick = () => { difficulty = 'medium'; initializeBoard(); showScreen(''); };
    document.getElementById('hardBtn').onclick = () => { difficulty = 'hard'; initializeBoard(); showScreen(''); };
    document.getElementById('gameOverNewGame').onclick = () => showScreen('menuScreen');

    // Show/hide screens
    function showScreen(id) {
      document.querySelectorAll('.overlayScreen').forEach(s => s.style.display = 'none');
      if (id) document.getElementById(id).style.display = 'flex';
    }

    // Keyboard shortcut to return to menu
    document.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === 'm') showScreen('menuScreen');
    });

    // Start with the menu screen
    showScreen('menuScreen');
  </script>
</body>
</html>
