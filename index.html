<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented â€“ Penti Grammai</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
      text-align: center;
      line-height: 1.2;
    }
    #gameContainer {
      position: relative;
      width: 360px;
      max-width: 100%;
      margin-bottom: 10px;
    }
    canvas {
      display: block;
      background: #eee;
      width: 100%;
      height: auto;
      border: 2px solid #333;
      touch-action: none;
    }
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255,255,255,0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
      z-index: 10;
    }
    button {
      font-size: 18px;
      padding: 10px 20px;
      margin: 5px;
      cursor: pointer;
    }
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
  </style>
</head>
<body>

  <h1>Another Product Invented<br>Penti Grammai</h1>

  <div id="gameContainer">
    <canvas id="gameCanvas" width="360" height="360"></canvas>

    <div id="menuScreen" class="overlayScreen" style="display:flex;">
      <button onclick="startGame()">New Game</button>
      <button onclick="showInstructions()">Instructions</button>
    </div>

    <div id="instructionsScreen" class="overlayScreen">
      <h2>How to Play Penti Grammai</h2>
      <p>ðŸ”¸ All your pieces start on the third line (middle of the board), on your side.</p>
      <p>ðŸ”¸ Move your pieces anti-clockwise around the board based on dice rolls.</p>
      <p>ðŸ”¸ You cannot move to a space if it's already occupied.</p>
      <p>ðŸ”¸ If you have no valid moves, your turn is skipped.</p>
      <p>ðŸ”¸ You can only enter home (center) if all your pieces have left your starting line.</p>
      <p>ðŸ”¸ You cannot enter home if the entry point is blocked.</p>
      <p>ðŸ”¸ First to get all pieces home wins!</p>
      <button onclick="showScreen('menuScreen')">Back to Menu</button>
    </div>

    <div id="gameOverScreen" class="overlayScreen">
      <h2 id="resultText"></h2>
      <button onclick="startGame()">New Game</button>
      <button onclick="showScreen('menuScreen')">Menu</button>
    </div>
  </div>

  <img id="logo" src="logo.png" alt="Logo">

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const track = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
    let playerPieces = [0,1,2,3,4]; // starting indexes on one side of central line
    let aiPieces = [8,9,10,11,12]; // AI on the other side
    let homePlayer = [], homeAI = [];
    let currentPlayer = 'player';
    let diceRoll = 0;
    let gameActive = true;

    function showScreen(id){
      document.querySelectorAll('.overlayScreen').forEach(s=>s.style.display='none');
      if(id) document.getElementById(id).style.display='flex';
    }

    function showInstructions(){
      showScreen('instructionsScreen');
    }

    function startGame(){
      playerPieces = [0,1,2,3,4];
      aiPieces = [8,9,10,11,12];
      homePlayer = [];
      homeAI = [];
      currentPlayer = 'player';
      gameActive = true;
      showScreen('');
      drawBoard();
      setTimeout(playerTurn, 500);
    }

    function drawBoard(){
      ctx.clearRect(0,0,360,360);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;

      for(let i=0; i<5; i++){
        ctx.beginPath();
        ctx.moveTo(60, 60 + i*60);
        ctx.lineTo(300, 60 + i*60);
        ctx.stroke();
      }

      for(let i=0; i<playerPieces.length; i++){
        drawPiece(track[playerPieces[i]], 'blue', i);
      }
      for(let i=0; i<aiPieces.length; i++){
        drawPiece(track[aiPieces[i]], 'red', i);
      }
      for(let i=0; i<homePlayer.length; i++){
        drawHome('blue', i);
      }
      for(let i=0; i<homeAI.length; i++){
        drawHome('red', i);
      }
    }

    function drawPiece(pos, color, index){
      let x = 90 + (index%2)*180;
      let y = 60 + (index%5)*60;
      ctx.beginPath();
      ctx.arc(x, y, 20, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    }

    function drawHome(color, index){
      let x = 180;
      let y = 60 + index*30;
      ctx.beginPath();
      ctx.arc(x, y, 10, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    }

    function playerTurn(){
      if (!gameActive) return;
      diceRoll = Math.floor(Math.random()*6)+1;
      let movable = playerPieces.filter(p => !isBlocked(p, diceRoll, playerPieces, aiPieces));
      if (movable.length === 0) {
        currentPlayer = 'ai';
        setTimeout(aiTurn, 1000);
        return;
      }
      let choice = movable.length === 1 ? movable[0] : movable[0]; // auto for now
      movePiece(choice, diceRoll, 'player');
    }

    function aiTurn(){
      if (!gameActive) return;
      diceRoll = Math.floor(Math.random()*6)+1;
      let movable = aiPieces.filter(p => !isBlocked(p, diceRoll, aiPieces, playerPieces));
      if (movable.length === 0) {
        currentPlayer = 'player';
        setTimeout(playerTurn, 1000);
        return;
      }
      let choice = movable[Math.floor(Math.random()*movable.length)];
      movePiece(choice, diceRoll, 'ai');
    }

    function isBlocked(pos, roll, ownPieces, opponent){
      let newPos = pos + roll;
      return ownPieces.includes(newPos) || opponent.includes(newPos) || newPos >= track.length;
    }

    function movePiece(pos, roll, who){
      let newPos = pos + roll;
      if (newPos >= track.length) return;

      let own = who === 'player' ? playerPieces : aiPieces;
      let opponent = who === 'player' ? aiPieces : playerPieces;
      let home = who === 'player' ? homePlayer : homeAI;

      if (opponent.includes(newPos)) {
        opponent.splice(opponent.indexOf(newPos),1);
      }

      own[own.indexOf(pos)] = newPos;

      if (newPos === track.length - 1 && own.every(p => p !== 0 && p !== 1 && p !== 2 && p !== 3 && p !== 4)) {
        home.push(newPos);
        own.splice(own.indexOf(newPos),1);
      }

      drawBoard();
      checkWin();
      currentPlayer = who === 'player' ? 'ai' : 'player';
      setTimeout(currentPlayer === 'player' ? playerTurn : aiTurn, 1000);
    }

    function checkWin(){
      if (homePlayer.length === 5) {
        gameActive = false;
        document.getElementById('resultText').textContent = "You Win!";
        showScreen('gameOverScreen');
      }
      if (homeAI.length === 5) {
        gameActive = false;
        document.getElementById('resultText').textContent = "You Lose!";
        showScreen('gameOverScreen');
      }
    }

    showScreen('menuScreen');
  </script>
</body>
</html>
